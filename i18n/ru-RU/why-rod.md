# Почему Rod

Есть много замечательных проектов, но никто не является идеальным, важно выбрать лучшее, что соответствует вашим потребностям.

## По сравнению с другими библиотеками

### Хромедип

Теоретически, стержень должен выполнять быстрее и потреблять меньше памяти, чем Chromedp.

[Chromedp][chromedp] использует браузер по умолчанию, это может вызвать проблемы, если вы случайно обновите браузер.

[Chromedp][chromedp] uses a [fix-sized buffer](https://github.com/chromedp/chromedp/blob/b56cd66/target.go#L69-L73) for events, it can cause dead-lock on high concurrency. Поскольку Chromedp использует один цикл событий, медленные обработчики событий блокируют друг друга. Rod не имеет этих проблем, потому что он основан на [goob](https://github.com/ysmood/goob).

Chromedp декодирует каждое сообщение от браузера, шнур декодирует, так что Rod работает лучше, особенно для тяжелых сетевых событий.

Chromedp использует третью часть веб-сокета lib, которая имеет [1MB более](https://github.com/chromedp/chromedp/blob/b56cd66f9cebd6a1fa1283847bbf507409d48225/conn.go#L43-L54) для каждого клиента cdp, если вы хотите управлять тысячами удаленных браузеров, это может стать проблемой. Из-за этого ограничения, если вы оцените js скрипт больше чем 1MB, Chromedp сломается, Вот пример того, как легко можно вызвать сбой Chromedp: [gist](https://gist.github.com/ysmood/0d5b2c878ecbdb598776af7d3d305b79).

Когда произойдет сбой, Chromedp покинет браузер зомби на Windows и Mac.

Rod является более настраиваемым, например, вы можете даже заменить lib WebSocket на нужную вам библиотеку.

Для прямого сравнения кода смотрите [здесь](https://github.com/go-rod/rod/tree/master/lib/examples/compare-chromedp). Если вы сравниваете пример с `логикой` между [стержнем](https://github.com/go-rod/rod/tree/master/lib/examples/compare-chromedp/logic/main.go) и [хромедпом](https://github.com/chromedp/examples/blob/master/logic/main.go), Вы узнаете, как простейший стержень.

С Chromedp вы должны использовать их подробные DSL-задачи, чтобы обработать логику кода. Chromedp использует несколько оберток для выполнения с помощью контекста и опций, что делает очень сложным понимание их кода при возникновении ошибок. Широко используемые интерфейсы делают статические типы бесполезными при отслеживании проблем. В отличие от этого, Rod использует как можно меньше интерфейсов.

У Rod меньше зависимостей, более простая структура кода и лучшая автоматизация тестов. Вам будет легче пополнить код на Rod. Поэтому по сравнению с Chromedp, Rod обладает потенциалом иметь больше приятных функций от сообщества в будущем.

Другая проблема Chromedp — их архитектура основана на [узле DOM id](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-NodeId), Шаппетер и стержень основаны на [удаленном объекте id](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObjectId). Следовательно, это не только [медленнее](https://github.com/puppeteer/puppeteer/issues/2936) и не позволяет Chromedp добавлять высокоуровневые функции, которые сочетаются с временем выполнения. Например, этот [билет](https://github.com/chromedp/chromedp/issues/72) был открыт в течение 3 лет. Даже после закрытия вы не сможете оценить js на элементе внутри iframe. Кроме того, Chromedp сохраняет [копию](https://github.com/chromedp/chromedp/blob/e2970556e3d05f3259c464faeed1ec0e862f0560/target.go#L375-L376) всех узлов в памяти. Это вызовет состояние гонки между локальным списком NodeID и [DOM.documentUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-documentUpdated), что может привести к путанице таких проблем, как [#762](https://github.com/chromedp/chromedp/issues/762).

### Щупальца

[Puppeteer][puppeteer] будет декодировать каждое сообщение из браузера, Rod декодирует по требованию, поэтому теоретически Rod будет работать лучше, особенно для тяжелых сетевых событий.

С puppeteer, вам нужно много обработать promise/async/await, это очень сложно сделать элегантный [беглый интерфейс](https://en.wikipedia.org/wiki/Fluent_interface). Тест от конца до конца требует много операций синхронизации для имитации входов человека, потому что Puppeteer основан на Nodejs все операции IO асинхронные вызовы, поэтому, как правило, люди заканчивают типичные тонны асинхронного/ожидания. Если вы забудете написать `в ожидании`, обычно болезненно отладить Промизку. Накладные расходы растут, когда ваш проект растет.

По умолчанию Rod безопасный по умолчанию, и имеет лучшие внутренние комментарии о том, как работает Rod. Имеет привязки типов для всех конечных точек протокола Devtools.

Rod будет отключать события домена, когда это возможно, puppeteer всегда включит все домены. Для работы с удаленным браузером требуется много ресурсов.

Rod лучше поддерживает отмену и тайм-аут, это может быть очень важно, если вы хотите обрабатывать тысячи страниц. For example, to simulate `click` we have to send serval cdp requests, with [Promise](https://stackoverflow.com/questions/29478751/cancel-a-vanilla-ecmascript-6-promise-chain) you can't achieve something like "only send half of the cdp requests", but with the [context](https://golang.org/pkg/context/) we can.

### Плей-офф

Жезл и [Playwright](https://github.com/microsoft/playwright) были впервые опубликованы почти одновременно. Большинство сравнений между Родом и Пуппетером остаются верными Playwright, поскольку как Playwright, так и Puppeteer поддерживаются почти теми же участниками.

Как заявил Playwright, "Playwright обеспечивает надежное сквозное тестирование современных веб-приложений", в центре внимания проекта находится тестирование. Но фокус на Rod является более общим, как для веб-автоматизации и скрапления, которые делают дизайн более сосредоточенным на гибкости и производительности.

Одна из архитектурных целей Рода заключается в том, чтобы каждый мог внести свой вклад и сделать его чистым общинным проектом. это одна из причин почему я выбрал Golang и MIT лицензию. Typescript - это хороший выбор, но если вы проверьте выбор дизайна Playwright; [`любые`](https://www.typescriptlang.org/docs/handbook/basic-types.htmvl#any) и [союз](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types) везде, если вы пытаетесь перейти к исходному коду страницы [. lick](https://playwright.dev/#version=v1.6.2&path=docs%2Fapi.md&q=pageclickselector-options), `d.ts` файлы позволят вам понять реальность typescript. Голанг определенно не достаточно хороший, но обычно он вводит меньше задолженности по технологиям, чем по отношению к узлу. s typescript, если вы хотите, чтобы я выбрал, какой из них использовать для QA или Infra, которые не знакомы с программированием для автоматизации сквозного теста или мониторинга сайтов, Я бы выбрал Голанг.

Их усилия по поддержке кросс-браузера замечательны. Но в настоящее время HTML5 хорошо адаптированы основными брендами, трудно сказать сложность, которую она приносит может весить выгоды. Станет ли кросс-браузер [патчи](https://github.com/microsoft/playwright/tree/master/browser_patches) бременем в будущем? Проблемы безопасности патчатых браузеров - это еще одна проблема. Он также делает сложным тестирование старых версий Firefox или Safari. Надеюсь, что это не пере-инжиниринг.

### Selenium

[Selenium](https://www.selenium.dev/) основан на [протоколе webdriver](https://www.w3.org/TR/webdriver/) , который имеет гораздо меньше функций по сравнению с [протоколом devtools](https://chromedevtools.github.io/devtools-protocol). Например, он не может справиться с [закрытым теневым DOM](https://github.com/sukgu/shadow-automation-selenium/issues/7#issuecomment-563062460). Нет способа сохранить страницы в PDF. Нет поддержки таких инструментов, как [Профайлер](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/) или [Производительность](https://chromedevtools.github.io/devtools-protocol/tot/Performance/)и т. д.

Трудно настроить и поддерживать из-за дополнительных зависимостей, таких как драйвер браузера.

Хотя selenium продает себе для лучшей поддержки кросс-браузера, обычно очень трудно заставить его работать для всех основных браузеров.

"selenium vs puppeteer", вы можете рассматривать стержень как Голанский вариант Puppeteer.

### Кипресс

[Cypress](https://www.cypress.io/) очень ограничен, для закрытой тени или кросс-доменной iframes, она почти непригодна для использования. Читайте их [ограничения](https://docs.cypress.io/guides/references/trade-offs.html) для получения более подробной информации.

Если вы хотите сотрудничать с нами, чтобы создать целевую базу тестирования на Rod для преодоления ограничения кипресса, пожалуйста, свяжитесь с нами.

## Что означает стержень

Rod - название устройства управления для щенка, например, коричневая палка на изображении ниже:

![стержень](https://user-images.githubusercontent.com/1415488/80178856-31cd8880-863a-11ea-83e9-64f84be3282d.png ":size=200")

Это означает, что мы являемся кукольником, браузер является кукольником, мы используем кукол для управления кукольником.

[chromedp]: https://github.com/chromedp/chromedp
[puppeteer]: https://github.com/puppeteer/puppeteer
