# خطأ في التعامل

في الفصول السابقة، رأينا الكثير من `يجب` طرق مسبقة مثل `MustNavigate`، `MustElement`، إلخ. جميعهم لديهم إصدارات غير محددة مسبقاً مثل `التنقل`، `عنصر`، إلخ. الفرق الرئيسي بينهم هو كيف يتعاملون مع الأخطاء . إنها ليست مميزة لرود، يمكنك العثور عليها في المكتبة القياسية مثل [regex.MustCompile](https://golang.org/pkg/regexp/#MustCompile).

الأساليب مثل `MustNavigate` و `MustElement` شائعة الاستخدام في الكود البرمجي أو سكريبت سريع. وهي مفيدة لوظائف مثل اختبار الدخان، ورصد الموقع، والاختبار من النهاية إلى النهاية، وما إلى ذلك. الوظائف مع الكثير من عدم اليقين، مثل تخريد الويب، النسخة غير الثابتة مسبقا ستكون خيارا أفضل.

الإصدار المحدد مسبقاً هو فقط الإصدار غير الثابت مسبقاً المغلف بالتحقق من الأخطاء. إليك رمز المصدر لـ `MustElement`، كما ترون أنه ينادي فقط بالعنصر `` مع عدة خطوط إضافية للذعر إذا لم يكن الخطأ `صفر`:

```go
تموج (p *الصفحة) MustElement(المحددات ...سلسلة) *عنصر {
    ell، الخطأ := p.Element(selectors...)
    إذا حدث خطأ != صفر {
        الذعر (err)
    }
    ارجع el
}
```

## الحصول على قيمة الخطأ

كتلتي التعليمات البرمجية أدناه يفعلان نفس الشيء تقريبا بطريقتين.

النمط أدناه هو الطريقة القياسية للتعامل مع الأخطاء:

```go
الصفحة := rod.New().MustConnect().MustPage("https://example.com")

elel، الخطأ := الصفحة. كلمات ("a")
إذا كانت خاطئة! لا شيء
    handleError(err)
    العودة
}
html, err := el. TML()
if err != nl {
    handleError(err)
    return
}
fmt.Println(html)
```

يمكننا استخدام `rod.حاول` لالتقاط الخطأ من `يجب` طرق مسبقة `MustElement` و `MustHTML`. النمط أدناه سينتهي عادة برمز أقل، ولكن قد يصطدم أيضا بأخطاء إضافية:

```go
الصفحة := rod.New().MustConnect().MustPage("https://example.com")

err := rod.Try(function() {
    fmt.Println(page.MustElement("a").MustHTML())
})
handleError(err)
```

## تحقق من نوع الخطأ

نحن نستخدم طريقة الذهاب القياسية للتحقق من أنواع الأخطاء، لا السحر.

قد يبدو خطأ `handleror` في التعليمة البرمجية أعلاه مثل:

```go
تمويل handleError(err error) {
    var evalErr *rod.ErrEval
    if errors.Is(err, context eadlineExceeded) { // مهلة الخطأ
        fmt.Println("مهلة خطأ")
    } أخرى في حالة الأخطاء. s(err, &evalErr) { // eval خطأ
        fmt.Println(evalErr. nNumber)
    } أخرى إذا كان الخطأ != لا شيء!
        fmt. rintln("لا يمكن التعامل مع"، خطأ)
    }
}
```
