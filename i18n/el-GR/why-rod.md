# Γιατί Ράβδος

Υπάρχουν πολλά μεγάλα έργα, αλλά κανείς δεν είναι τέλειος, επιλέξτε το καλύτερο που ταιριάζει στις ανάγκες σας είναι σημαντικό.

## Σε σύγκριση με άλλα χείλη

### Χρωματισμός

Θεωρητικά, Rod θα πρέπει να εκτελέσει πιο γρήγορα και να καταναλώνουν λιγότερη μνήμη από Chromedp.

[Το Chromedp][chromedp] χρησιμοποιεί τον περιηγητή του συστήματος από προεπιλογή, μπορεί να προκαλέσει προβλήματα αν αναβαθμίσετε κατά λάθος το πρόγραμμα περιήγησης.

[Το Chromedp][chromedp] χρησιμοποιεί ένα [fix-size buffer](https://github.com/chromedp/chromedp/blob/b56cd66/target.go#L69-L73) για εκδηλώσεις, μπορεί να προκαλέσει αδιέξοδο σε υψηλή συνάλλαγμα. Επειδή το Chromedp χρησιμοποιεί έναν βρόχο γεγονότος, οι χειριστές αργών γεγονότων θα μπλοκάρουν ο ένας τον άλλον. Το Rod δεν έχει αυτά τα ζητήματα επειδή βασίζεται στο [goob](https://github.com/ysmood/goob).

Το Chromedp θα αποκωδικοποιήσει κάθε μήνυμα από το πρόγραμμα περιήγησης, η ράβδος αποκωδικοποίησης, έτσι ώστε το Rod να αποδίδει καλύτερα, ειδικά για βαριά δικτυακά συμβάντα.

Το Chromedp χρησιμοποιεί το τρίτο μέρος WebSocket lib το οποίο έχει [1MB εναέρια γραμμή](https://github.com/chromedp/chromedp/blob/b56cd66f9cebd6a1fa1283847bbf507409d48225/conn.go#L43-L54) για κάθε πελάτη cdp, αν θέλετε να ελέγξετε χιλιάδες απομακρυσμένα προγράμματα περιήγησης μπορεί να γίνει ένα πρόβλημα. Λόγω αυτού του περιορισμού, αν αξιολογήσετε ένα js script μεγαλύτερο από 1MB, το Chromedp θα συντριβεί, εδώ είναι ένα παράδειγμα του πόσο εύκολο μπορείτε να συντριβή Chromedp: [gist](https://gist.github.com/ysmood/0d5b2c878ecbdb598776af7d3d305b79).

Όταν συμβεί μια κατάρρευση, το Chromedp θα αφήσει τη διαδικασία περιηγητή ζόμπι στα Windows και Mac.

Το Rod είναι πιο διαμορφώσιμο, όπως μπορείτε ακόμη και να αντικαταστήσετε το WebSocket lib με το lib που σας αρέσει.

Για άμεση σύγκριση κωδικών, μπορείτε να ελέγξετε [εδώ](https://github.com/go-rod/rod/tree/master/lib/examples/compare-chromedp). Αν συγκρίνετε το παράδειγμα που ονομάζεται `λογική` μεταξύ [ράβδου](https://github.com/go-rod/rod/tree/master/lib/examples/compare-chromedp/logic/main.go) και [chromedp](https://github.com/chromedp/examples/blob/master/logic/main.go), θα μάθετε πόσο απλούστερη είναι η ράβδος .

Με το Chromedp, πρέπει να χρησιμοποιήσετε τις αναλυτικές DSL εργασίες τους για να χειριστείτε τη λογική κώδικα. Το Chromedp χρησιμοποιεί πολλά περιτυλίγματα για να χειριστεί την εκτέλεση με συμφραζόμενα και επιλογές, γεγονός που καθιστά πολύ δύσκολο να κατανοήσει τον κώδικά τους όταν συμβαίνουν σφάλματα. Οι βαριά χρησιμοποιούμενες διεπαφές καθιστούν τους στατικούς τύπους άχρηστους κατά την παρακολούθηση ζητημάτων. Αντίθετα, το Rod χρησιμοποιεί όσο το δυνατόν λιγότερες διεπαφές.

Rod έχει λιγότερες εξαρτήσεις, μια απλούστερη δομή κώδικα και καλύτερη αυτοματοποίηση δοκιμών. Θα πρέπει να βρείτε ότι είναι πιο εύκολο να συνεισφέρετε κώδικα στο Rod. Ως εκ τούτου, σε σύγκριση με το Chromedp, το Rod έχει τη δυνατότητα να έχει πιο ωραίες λειτουργίες από την κοινότητα στο μέλλον.

Ένα άλλο πρόβλημα του Chromedp είναι η αρχιτεκτονική τους βασίζεται στο [DOM node id](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-NodeId), κουκλοθέατρο και ράβδος βασίζονται σε [id απομακρυσμένου αντικειμένου](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObjectId). Κατά συνέπεια, δεν είναι μόνο [πιο αργό](https://github.com/puppeteer/puppeteer/issues/2936) και επίσης αποτρέπει το Chromedp από την προσθήκη λειτουργιών υψηλού επιπέδου που συνδέονται με το χρόνο εκτέλεσης. Για παράδειγμα, αυτό το [εισιτήριο](https://github.com/chromedp/chromedp/issues/72) είχε ανοίξει για 3 χρόνια. Ακόμα και όταν είναι κλειστό, ακόμα δεν μπορείτε να αξιολογήσει js express στο στοιχείο μέσα σε ένα iframe. Εκτός αυτού, το Chromedp διατηρεί ένα [αντίγραφο](https://github.com/chromedp/chromedp/blob/e2970556e3d05f3259c464faeed1ec0e862f0560/target.go#L375-L376) όλων των κόμβων στη μνήμη. Θα προκαλέσει συνθήκες ανταγωνισμού μεταξύ της τοπικής λίστας NodeID και [DOM.documentUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-documentUpdated), η οποία μπορεί να προκαλέσει σύγχυση σε ζητήματα όπως [#762](https://github.com/chromedp/chromedp/issues/762).

### Κουκλοθέατρο

[Puppeteer][puppeteer] θα αποκωδικοποιήσει JSON κάθε μήνυμα από το πρόγραμμα περιήγησης, Rod είναι αποκωδικοποιητή κατά παραγγελία, οπότε θεωρητικά ο Rod θα εκτελέσει καλύτερα, ειδικά για βαριά συμβάντα δικτύου.

Με το κουκλοθέατρο, πρέπει να χειριστείτε πολύ την υπόσχεση/async/περιμένετε, κάνει το κομψό [άπταιστα σχεδίαση](https://en.wikipedia.org/wiki/Fluent_interface) πολύ δύσκολο. Τέλος στις τελικές δοκιμές απαιτεί πολλές λειτουργίες συγχρονισμού για την προσομοίωση των ανθρώπινων εισροών, επειδή Puppeteer βασίζεται σε Nodejs όλες οι λειτουργίες IO είναι ασύγκριτες κλήσεις, έτσι συνήθως, οι άνθρωποι καταλήγουν πληκτρολογώντας τόνους του async/await. Αν ξεχάσετε να γράψετε ένα `περιμένετε`, είναι συνήθως οδυνηρό να αποσφαλματώσετε τη διαρροή υποσχέσεων. Το γενικό επίπεδο μεγαλώνει όταν μεγαλώνει το έργο σας.

Ράβδος είναι τύπου ασφαλή από προεπιλογή, και έχει καλύτερα εσωτερικά σχόλια σχετικά με το πώς λειτουργεί η ίδια Rod. Διαθέτει συνδέσεις τύπου για όλα τα τελικά σημεία στο πρωτόκολλο Devtools.

Το Rod θα απενεργοποιήσει τα domain events όποτε είναι δυνατόν, το puppeteer θα ενεργοποιεί πάντα όλους τους τομείς. Θα καταναλώνει πολλούς πόρους κατά την οδήγηση ενός απομακρυσμένου προγράμματος περιήγησης.

Ράβδος υποστηρίζει ακύρωση και το χρονικό όριο καλύτερα, αυτό μπορεί να είναι κρίσιμο αν θέλετε να χειριστεί χιλιάδες σελίδες. Για παράδειγμα, για να προσομοιώσουμε `κάντε κλικ` πρέπει να στείλουμε αιτήματα serval cdp, με [υπόσχεση](https://stackoverflow.com/questions/29478751/cancel-a-vanilla-ecmascript-6-promise-chain) δεν μπορείτε να επιτύχετε κάτι σαν "να στείλετε μόνο τα μισά από τα αιτήματα cdp", but with the [context](https://golang.org/pkg/context/) we can.

### Playwright

Η ράβδος και το [Playwright](https://github.com/microsoft/playwright) δημοσιεύθηκαν για πρώτη φορά σχεδόν ταυτόχρονα. Οι περισσότερες συγκρίσεις μεταξύ του Rod και του Puppeteer παραμένουν αληθείς στο Playwright, επειδή τόσο το Playwright όσο και το Puppeteer συντηρούνται από σχεδόν τους ίδιους συνεισφέροντες.

Όπως δήλωσε το Playwright στο doc τους "Το Playwright επιτρέπει αξιόπιστες δοκιμές end-to-end για σύγχρονες εφαρμογές ιστού". Αλλά η εστίαση για Rod είναι πιο γενική, τόσο για web αυτοματοποίηση και απόξεση, τα οποία κάνουν το σχεδιασμό να επικεντρωθεί περισσότερο στην ευελιξία και την απόδοση.

Ένας από τους αρχιτεκτονικούς στόχους του Rod είναι να διευκολύνει όλους να συνεισφέρουν και να το κάνουν ένα καθαρό κοινοτικό έργο, that's one bigμεγάλο reason why I chose Golang and the MIT license. Το Typescript είναι μια ωραία επιλογή αλλά αν ελέγξετε τις επιλογές σχεδιασμού του Playwright, [`οποιοιδήποτε`](https://www.typescriptlang.org/docs/handbook/basic-types.htmvl#any) και [τύποι ένωσης](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types) είναι παντού, αν προσπαθήσετε να μεταβείτε στον πηγαίο κώδικα της σελίδας [. κάντε κλικ](https://playwright.dev/#version=v1.6.2&path=docs%2Fapi.md&q=pageclickselector-options), `d.ts` αρχεία θα σας επιτρέψουν να κατανοήσετε την πραγματικότητα της δακτυλογραφίας. Το Golang σίγουρα δεν είναι αρκετά καλό, αλλά συνήθως εισάγει λιγότερο χρέος τεχνολογίας από τον κόμβο. s typescript, if you want me to choose which one to use for QA or Infra who are not familiar with coding to automate end-to-end test or site-monitoring, Θα ήθελα να επιλέξω Golang.

Η προσπάθειά τους για υποστήριξη cross-browser είναι υπέροχη. Αλλά σήμερα, το HTML5 υιοθετείται καλά από τις κύριες μάρκες, είναι δύσκολο να πούμε την πολυπλοκότητα που φέρνει μπορεί να επιβαρύνει τα οφέλη. Θα το cross-browser [διορθώσεις](https://github.com/microsoft/playwright/tree/master/browser_patches) γίνει ένα βάρος στο μέλλον? Τα ζητήματα ασφαλείας για τους περιηγητές είναι μια άλλη ανησυχία. Καθιστά επίσης δύσκολο να δοκιμάσετε παλιές εκδόσεις του Firefox ή Safari. Η ελπίδα δεν είναι υπερ-μηχανική.

### Selenium

[Το Selenium](https://www.selenium.dev/) βασίζεται στο [πρωτόκολλο οδηγού ιστού](https://www.w3.org/TR/webdriver/) το οποίο έχει πολύ λιγότερες λειτουργίες σε σύγκριση με το [πρωτόκολλο devtools](https://chromedevtools.github.io/devtools-protocol). Όπως δεν μπορεί να χειριστεί [κλειστή σκιά DOM](https://github.com/sukgu/shadow-automation-selenium/issues/7#issuecomment-563062460). Δεν υπάρχει τρόπος για να αποθηκεύσετε σελίδες ως PDF. Δεν υπάρχει υποστήριξη για εργαλεία όπως το [Profiler](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/) ή [Performance](https://chromedevtools.github.io/devtools-protocol/tot/Performance/), κλπ.

Είναι πιο δύσκολο να ρυθμίσετε και να διατηρήσετε λόγω επιπλέον εξαρτήσεων όπως ένας οδηγός περιήγησης.

Αν και το σελήνιο πωλείται για καλύτερη υποστήριξη από διασταυρούμενο πρόγραμμα περιήγησης, είναι συνήθως πολύ δύσκολο να το κάνει να λειτουργήσει για όλα τα μεγάλα προγράμματα περιήγησης.

Υπάρχουν πολλά άρθρα σχετικά με το "σελήνιο εναντίον κουκλοθέατρο", μπορείτε να αντιμετωπίσετε τη ράβδο ως την έκδοση Golang του Puppeteer.

### Κυπαρίσσι

[Το Cypress](https://www.cypress.io/) είναι πολύ περιορισμένο, καθώς η κλειστή σκιά dom ή τα διατομεακά iframes είναι σχεδόν άχρηστα. Διαβάστε το [doc περιορισμού](https://docs.cypress.io/guides/references/trade-offs.html) για περισσότερες λεπτομέρειες.

Αν θέλετε να συνεργαστείτε μαζί μας για να δημιουργήσετε μια βάση δοκιμών εστιασμένη στο Rod για να ξεπεραστεί ο περιορισμός του κυπαρίσσιου, παρακαλούμε επικοινωνήστε μαζί μας.

## Τι σημαίνει Rod

Ράβδος είναι το όνομα της συσκευής ελέγχου για κουκλοθέατρο, όπως το καφέ ραβδί στην παρακάτω εικόνα:

![ορ](https://user-images.githubusercontent.com/1415488/80178856-31cd8880-863a-11ea-83e9-64f84be3282d.png ":size=200")

Το νόημα είναι ότι είμαστε το κουκλοθέατρο, το πρόγραμμα περιήγησης είναι το κουτάβι, χρησιμοποιούμε τη ράβδο για τον έλεγχο του κουταβιού.

[chromedp]: https://github.com/chromedp/chromedp
[puppeteer]: https://github.com/puppeteer/puppeteer
