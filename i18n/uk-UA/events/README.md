# Події

Події – це дії або входження, що відбуваються у браузері що ви контролюєте, який браузер вам розповідає, щоб ви могли відповісти на них певним чином, якщо це необхідно. Такі, як коли ми дозволяємо сторінці переходити в новий URL, ми можемо підписатись на події, щоб знати, коли навігація завершена або при перегляді сторінки.

## Чекати раз на подію

Давайте спробуємо переміститися на сторінку та чекати, поки мережа сторінки буде майже простою:

```go
func main() {
    сторінка := rod.New().MustConnect().MustPage()

    очікувати:= page.MustWaitNavigation()
    page.MustNavigate("https://www.wikipedia.org/")
    wait()

```

Ми використовуємо `MustWaitNavigation` для підписки на події простою мережею. Причина, з якої підписка перед навігацією не після цього, так як код для запуску навігації зайвий час для виконання за цей час подія, можливо, вже відбулася. Після `передачі` ми викликаємо `функцію` щоб заблокувати код, доки не відбудеться наступна подія бездіяльності в мережі.

Род надає багато інших помічників заходу, всі назви функцій попередньо фіксуються за допомогою `MustWait` або `Зачекайте`.

## Отримати деталі події

Типи подій тримають деталі про саму подію. Наприклад під час навігації по URL і використовуючи події, щоб отримати код відповіді на навігаційний запит:

```go
func main() {
    сторінка := rod.New().MustConnect().MustPage()

    e := proto.NetworkResponseReceiseReceived{}
    wait := page.WaitEvent(&e)
    page.MustNavigate("https://www.wikipedia.org/")
    wait()

    fmt.Println(e.Response.Status)

```

## Обробляти кілька подій

Якщо ви хочете впоратися з усіма подіями типу, наприклад, прослуховування всіх подій консолі сторінок , ми можемо зробити щось на зразок цього:

```go
go page.EachEvent(func(e *proto.RuntimeConsoleAPICalled) {
    fmt.Println(page.MustObjectsToJSON(e.Args))
})()
```

Щоб підписатися на кілька типів подій одночасно, наприклад, підписка `RuntimeConsoleAPICalled` та `PageLoadEventFired`:

```go
go page.EachEvent(func(e *proto.RuntimeConsoleAPICalled) {
    fmt.Println(page.MustObjectsToJSON(e.Args))
}, func(e *proto.PageLoadEventFired) {
    fmt.Println("loaded")
})()
```

## Зупинити підписку

Будь-яка функція в Розі, яку блоки можуть бути скасовані з [контекстом](context-and-timeout.md), це не спеціально для подій. Крім того, ви також можете зупинити подію, повернувши true з обробника подій, наприклад:

```go
wait := page.EachEvent(func(e *proto.PageLoadEventFired) (зупинити bool) {
    return true
})
page.MustNavigate("https://example.com")
wait()
```

Якщо ми не повернемося до правди, очікування на події `PageLoadEventred` та заблокуйте програму назавжди. Насправді це код, як працює `page.WaitEvent`.

## Доступні події

Всі типи подій реалізують `proto.Event` інтерфейс, ви можете його використовувати для пошуку всіх подій. Зазвичай IDE автоматично фільтруватиме за інтерфейсом автоматично. Такі, як ми хочемо побачити всі події під доменом сторінки, ми можемо створити порожній об'єкт сторінки і використовувати `WaitEvent(proto. вентиль)` вивести та відфільтрувати всі типи подій на зразок скріншоту нижче:

![список подій](event-list.png)

Ви також можете використовувати цей [сайт](https://chromedevtools.github.io/devtools-protocol/tot/Page) для перегляду подій.
