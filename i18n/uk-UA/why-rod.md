# Чому палиця

Багато великих проектів, але ніхто не ідеальний, вибирайте найкраще, що відповідає вашим потребам.

## У порівнянні з іншими губами

### Хромедп

Теоретично Род повинен працювати швидше і споживати менше пам'яті, ніж Chromedp.

[Chromedp][chromedp] використовує системний браузер, він може викликати проблеми, якщо ви випадково оновіть браузер.

[Chromedp][chromedp] використовує [буфер розміру фікса](https://github.com/chromedp/chromedp/blob/b56cd66/target.go#L69-L73) для подій, це може призвести до глухого блокування в високій валюті. Оскільки Chromedp використовує один цикл, повільні обробники подій будуть блокувати один одного. Род не має цих питань, так як він базується на [goob](https://github.com/ysmood/goob).

JSON декодувати кожне повідомлення в браузері - це декод-на попит, тому Rod працюватиме краще, особливо для важких мережевих подій.

Chromedp використовує третю частину WebSocket lib, яка містить [1MB overhead](https://github.com/chromedp/chromedp/blob/b56cd66f9cebd6a1fa1283847bbf507409d48225/conn.go#L43-L54) для кожного cdp клієнта, якщо ви хочете контролювати тисячі віддалених браузерів, вони можуть стати проблемою. Через це обмеження, якщо ви обчислюєте js скрипт більшого 1 МБ, Chromedp зазнає краху, Ось приклад того, як легко ви можете завершити роботу Chromedp: [gist](https://gist.github.com/ysmood/0d5b2c878ecbdb598776af7d3d305b79).

Коли станеться аварія, Chromedp покине процес роботи зомбі-браузера на Windows і Mac.

Род є більш налаштованим, наприклад, ви навіть можете замінити петлю WebSocket на яку вам до вподоби.

Для порівняння прямого коду ви можете перевірити [тут](https://github.com/go-rod/rod/tree/master/lib/examples/compare-chromedp). Якщо ви порівняєте приклад з назвою `логіка` між [палицею](https://github.com/go-rod/rod/tree/master/lib/examples/compare-chromedp/logic/main.go) і [chromedp](https://github.com/chromedp/examples/blob/master/logic/main.go), ви дізнаєтеся, наскільки простішою є мотузка.

З Chromedp, ви повинні використовувати їх докладні DSL-завдання для обробки логіки коду. Chromedp використовує декілька обгорток для роботи з контекстом і параметрами, що ускладнює розуміння їх коду, коли трапляються помилки. Інтерфейси з сильним вживанням роблять статичні типи непотрібними під час відстеження проблем. Навпаки, Роуд використовує якомога менше інтерфейсів.

Дорога має менше залежностей, простішу структуру коду і краще тестувати автоматизацію. Вам потрібно знайти простіше вносити свій код до Rod. Тому порівняно з Chromedp, Rod має потенціал до більш хороших функцій у спільноті в майбутньому.

Іншою проблемою Chromedp є їх архітектура заснована на [DOM node id](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#type-NodeId)лялька і паличка на основі [віддалений ідентифікатор об'єкту](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObjectId). В результаті це не лише [повільніше](https://github.com/puppeteer/puppeteer/issues/2936) і також не дозволяє Chromedp додавати високорівневі функції, з'єднані з часом виконання. Наприклад, цей [квиток](https://github.com/chromedp/chromedp/issues/72) відкрився протягом 3 років. Навіть після того, як він закритий, ви все ще не можете обчислити js вираження за елементом всередині iframe. Крім того, Chromedp підтримує [копію](https://github.com/chromedp/chromedp/blob/e2970556e3d05f3259c464faeed1ec0e862f0560/target.go#L375-L376) всіх вузлів в пам'яті. Це спричинить умову гонки між локальним списком NodeID і [DOM.documentUpdated](https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-documentUpdated), що може призвести до заплутаних проблем на зразок [#762](https://github.com/chromedp/chromedp/issues/762).

### Ластівка

[Puppeteer][puppeteer] JSON декодуватиме кожне повідомлення від браузера, Rod є декоде-на вимогу, отже теоретично Rod буде працювати краще, особливо для важких мережевих подій.

У цуценяті, вам необхідно багато користуватися обіцянками або async/await та робить вишуканий [вільно інтерфейс](https://en.wikipedia.org/wiki/Fluent_interface) дуже важким. Кінець тесту потребує багато операцій синхронізації, щоб симулювати людські дані, тому що Puppeteer базується на Nodejs всі операції з IO є асинхронними дзвінками, тому, як правило, люди в кінцевому підсумку вводять тонни async/await. Якщо ви забудете написати `чекає`, це, як правило, боляче виправити Promise. Накладення зростає коли ваш проект зростає.

За замовчуванням рожевий є типовим безпечним і має кращі внутрішні коментарі щодо того, як працює сам Роуд. Для всіх кінцевих точок протоколу Devtools його тип.

Rod вимкне доменні події, кожного разу, коли це можливо, щенята завжди увімкне усі домени. Буде витрачено багато ресурсів під час їзди на віддалений браузер.

Очок підтримує скасування і тайм-аут кращий, це може бути критично важливим якщо ви хочете впоратися з тисячами сторінок. Наприклад, щоб імітувати `клікніть` нам потрібно відправити запити на serval cdp, з [Promise](https://stackoverflow.com/questions/29478751/cancel-a-vanilla-ecmascript-6-promise-chain) ви не можете досягти чогось на зразок "відправити тільки половину запитів cdp", але з контекстом [](https://golang.org/pkg/context/) ми можемо.

### Драматург

Спочатку Rod і [Playwright](https://github.com/microsoft/playwright) було опубліковано майже одночасно. Більшість порівнянь Рода та Пуппетієра залишаються вірними Playwright, тому що і PlaywRight і Puppeteer підтримують майже ті ж розробники.

Як Playwright заявив про свою документацію "Playwright дає змогу надійно протестувати для сучасних веб-додатків". Основна увага до проекту - тестування. Але фокус гнізда є більш загальним, як для автоматизації, так і для автоматизації, так і для масштабування, що робить дизайн більш зосередженим на гнучкості та працездатності.

Однією з архітектурних цілей Рода є полегшення кожного внеску та зробити його чистим проектом громад, це одна велика причина, чому я обрав Голанг і ліцензію MIT. Typescript is a nice choice but if you check Playwright's design choices, [`any`](https://www.typescriptlang.org/docs/handbook/basic-types.htmvl#any) and [union types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types) are everywhere, if you try to jump to the source code of [page.click](https://playwright.dev/#version=v1.6.2&path=docs%2Fapi.md&q=pageclickselector-options), `d.ts` files will let you understand the reality of typescript. Голанг точно недостатньо хороший, але зазвичай впровадить менш технологічний борг, ніж вузол. s typescript, Якщо ви хочете, щоб я обрала, яку потрібно використовувати для QA чи Infra, які не знайомі з кодуванням для автоматизації нескінченного тестування чи моніторингу сайтів Я б вибрав Голанг.

Їхні зусилля для роботи з перехресним браузером сприятливі. Але сьогодні HTML5 добре прийнята основними брендами, важко сказати, що складність вірусу приносить пільги. Чи стане перехресний браузер [патчі](https://github.com/microsoft/playwright/tree/master/browser_patches) тягарем у майбутньому? Проблеми безпеки з пропатченими браузерами викликає ще одне занепокоєння. Також, це робить складним тестування старих версій Firefox або Safari. Надія - це не надмірно інженерія.

### Selenium

[Selenium](https://www.selenium.dev/) заснований на [протоколі веб-драйвера](https://www.w3.org/TR/webdriver/) , який має набагато менше функцій порівнюючи з [devtools protocol](https://chromedevtools.github.io/devtools-protocol). Такі, як він не може обробляти [закрита тінь DOM](https://github.com/sukgu/shadow-automation-selenium/issues/7#issuecomment-563062460). Не можна зберегти сторінки як PDF. Немає підтримки для таких інструментів, як [профілер](https://chromedevtools.github.io/devtools-protocol/tot/Profiler/) або [Продуктивності](https://chromedevtools.github.io/devtools-protocol/tot/Performance/)і т.д.

Важче налаштувати та підтримувати через додаткові залежності, такі як драйвер браузера.

Хоча селеній продає себе для кращої підтримки міжбраузера, як правило, дуже важко змусити його працювати для усіх основних браузерів.

У нас багато статей про "селеній проти ляльковою", ви можете розглядати гниль як версію Голанга Puppeteer.

### Кипарисова

[Кіпр](https://www.cypress.io/) дуже обмежений, для закритих тіні рідко або міждоменні iframes майже неможливо використати. Прочитайте їх [обмежувальний документ](https://docs.cypress.io/guides/references/trade-offs.html) для отримання додаткової інформації.

Якщо ви хочете співпрацювати з нами, щоб створити тестову сфокусовану базу на Rod для подолання обмеження шифрів, будь ласка, зв'яжіться з нами.

## Що означає Род

Род - це ім'я пульта для ляльки, наприклад, коричнева паличка у зображенні нижче:

![палиця](https://user-images.githubusercontent.com/1415488/80178856-31cd8880-863a-11ea-83e9-64f84be3282d.png ":size=200")

Знаючи це, ми є ляльковополоненим, браузер - це лялька, ми використовуємо палицю, щоб контролювати ляльки.

[chromedp]: https://github.com/chromedp/chromedp
[puppeteer]: https://github.com/puppeteer/puppeteer
